---
title: ডেটাবেস ম্যানেজমেন্ট
parent: Chapters
nav_order: 3
---

# ৩: ডেটাবেস ম্যানেজমেন্ট (Database Management)


প্রতিটি ডাইনামিক ওয়েবসাইটের হৃদপিণ্ড হলো তার ডেটাবেস। ওয়ার্ডপ্রেসও এর ব্যতিক্রম নয়। পোস্ট, পেজ, ইউজার, সেটিংস—সবকিছুই ডেটাবেসে সংরক্ষিত থাকে। একজন মিড-লেভেল ডেভেলপার হিসেবে আপনি হয়তো get\_posts(), update\_post\_meta() এর মতো ফাংশন ব্যবহার করে ডেটাবেসের সাথে কাজ করেছেন।

কিন্তু যখন আপনার প্লাগিনের ডেটা জটিল আকার ধারণ করে, অথবা যখন আপনার লক্ষ লক্ষ ডেটা এন্ট্রি নিয়ে কাজ করার প্রয়োজন হয়, তখন ওয়ার্ডপ্রেসের ডিফল্ট পোস্ট এবং মেটা টেবিল আর যথেষ্ট থাকে না।

এই অধ্যায়ে আমরা শিখব কীভাবে ওয়ার্ডপ্রেসের ডেটাবেস অ্যাবস্ট্র্যাকশন লেয়ার $wpdb ব্যবহার করে যেকোনো ধরনের কোয়েরি নিরাপদে চালানো যায়। এছাড়াও আমরা জানব কখন এবং কেন আমাদের নিজস্ব কাস্টম ডেটাবেস টেবিল তৈরি করা উচিত এবং কীভাবে প্লাগিন অ্যাক্টিভেশনের সময় সেই টেবিলগুলো তৈরি ও পরিচালনা করতে হয়।

#### ৩.১ $wpdb: ওয়ার্ডপ্রেসের ডেটাবেস গেটওয়ে

$wpdb হলো একটি গ্লোবাল অবজেক্ট, যা ওয়ার্ডপ্রেসের ডেটাবেসের সাথে সরাসরি কথা বলার জন্য একটি নিরাপদ এবং স্ট্যান্ডার্ড ইন্টারফেস প্রদান করে। আপনি যখনই কোনো কাস্টম SQL কোয়েরি চালাতে চাইবেন, $wpdb ব্যবহার করাই হবে সবচেয়ে সেরা এবং নিরাপদ উপায়।

নিরাপত্তা প্রথম: SQL Injection এবং $wpdb->prepare()

ডেটাবেসের সাথে কাজ করার সময় সবচেয়ে বড় ঝুঁকি হলো SQL Injection। এটি এমন একটি অ্যাটাক যেখানে একজন হ্যাকার আপনার কোয়েরির মধ্যে ক্ষতিকর SQL কোড প্রবেশ করিয়ে ডেটাবেসের নিয়ন্ত্রণ নেওয়ার বা তথ্য চুরি করার চেষ্টা করে।

ভুল পদ্ধতি (ঝুঁকিপূর্ণ):

```PHP
// !!! সতর্কতা: এই কোডটি SQL Injection এর জন্য ঝুঁকিপূর্ণ !!!
$user_id = $_GET['user_id'];
$results = $wpdb->get_results("SELECT * FROM wp_users WHERE ID = $user_id");
```

এখানে যদি কোনো হ্যাকার user\_id প্যারামিটারে 1 OR 1=1 এর মতো কিছু পাস করে, তাহলে কোয়েরিটি পরিবর্তিত হয়ে সব ইউজারের তথ্য দেখিয়ে দেবে।

সঠিক পদ্ধতি (নিরাপদ): $wpdb->prepare()

$wpdb->prepare() ফাংশনটি আপনার ডেটাকে নিরাপদে "sanitise" করে এবং কোয়েরির জন্য প্রস্তুত করে। এটি প্লেসহোল্ডার (%s স্ট্রিংয়ের জন্য, %d সংখ্যার জন্য, %f ফ্লোটিং পয়েন্ট নম্বরের জন্য) ব্যবহার করে, যা SQL Injection অ্যাটাককে প্রায় অসম্ভব করে তোলে।

```PHP
// এটি নিরাপদ এবং সঠিক পদ্ধতি
$user_id = intval($_GET['user_id']); // ইনপুটকে ইন্টিজারে কাস্ট করা একটি ভালো অভ্যাস
$query = $wpdb->prepare("SELECT * FROM {$wpdb->prefix}users WHERE ID = %d", $user_id);
$results = $wpdb->get_results($query);

```

মনে রাখবেন: যখনই কোনো ডাইনামিক ভ্যারিয়েবল (যেমন: user input, URL parameter) আপনার কোয়েরিতে ব্যবহার করবেন, $wpdb->prepare() ব্যবহার করা বাধ্যতামূলক।

সাধারণ $wpdb মেথড:

*   $wpdb->get\_results($query): একাধিক রো (row) অবজেক্ট হিসেবে ফেরত দেয়।

*   $wpdb->get\_row($query): শুধুমাত্র একটি রো ফেরত দেয়।

*   $wpdb->get\_var($query): শুধুমাত্র একটি মান (single value) ফেরত দেয়। যেমন: SELECT COUNT(\*) FROM ... এর ফলাফল।

*   $wpdb->insert($table, $data): একটি টেবিলে ডেটা ইনসার্ট করার সবচেয়ে সহজ ও নিরাপদ উপায়।

*   $wpdb->update($table, $data, $where): টেবিলের ডেটা আপডেট করার সহজ ও নিরাপদ উপায়।

*   $wpdb->delete($table, $where): টেবিল থেকে ডেটা ডিলিট করার সহজ ও নিরাপদ উপায়।


insert এর উদাহরণ:

```PHP
global $wpdb;
$table_name = $wpdb->prefix . 'my_custom_table';

$wpdb->insert(
    $table_name,
    [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'created_at' => current_time('mysql'),
    ],
    [
        '%s', // name (string)
        '%s', // email (string)
        '%s', // created_at (string)
    ]
);

```

#### **৩.২ কাস্টম ডেটাবেস টেবিল: কখন এবং কেন?**

ওয়ার্ডপ্রেসের wp\_posts এবং wp\_postmeta টেবিলগুলো খুবই শক্তিশালী, কিন্তু সব ধরনের ডেটার জন্য উপযুক্ত নয়। তাহলে প্রশ্ন হলো, কখন আপনার কাস্টম টেবিল তৈরি করা উচিত?

1.  যখন ডেটা স্ট্রাকচারড (Structured Data) হয়: আপনার ডেটা যদি পোস্ট বা পেজের মতো না হয়ে বরং একটি নির্দিষ্ট গঠন মেনে চলে (যেমন: লগ ফাইল, ফর্ম সাবমিশন, অ্যানালিটিক্স ডেটা), তখন কাস্টম টেবিল ব্যবহার করা ভালো। wp\_postmeta টেবিলটি key-value পেয়ার হিসেবে ডেটা রাখে, যা (complex) কোয়েরির জন্য ধীরগতির হতে পারে।

2.  যখন ডেটার পরিমাণ অনেক বেশি (High Volume Data) হয়: আপনার প্লাগিন যদি প্রতিদিন হাজার হাজার বা লক্ষ লক্ষ রেকর্ড তৈরি করে (যেমন: ভিজিটর লগ), তাহলে সেগুলোকে wp\_posts বা wp\_postmeta টেবিলে রাখলে সাইটের পারফরম্যান্স মারাত্মকভাবে কমে যাবে। একটি আলাদা, ইনডেক্স করা টেবিল অনেক বেশি কার্যকরী হবে।

3.  যখন ডেটা রিলেশনাল (Relational Data) হয়: যদি আপনার বিভিন্ন ধরনের ডেটার মধ্যে সম্পর্ক থাকে (যেমন: event, attendee এবং ticket টেবিলের মধ্যে সম্পর্ক), তখন কাস্টম টেবিল ব্যবহার করে proper relational database ডিজাইন তৈরি করা যায়।


একটি উদাহরণ: ধরুন আপনি একটি ইভেন্ট ম্যানেজমেন্ট প্লাগিন বানাচ্ছেন। ইভেন্টের তথ্য (wp\_posts-এ রাখা যেতে পারে) এবং প্রতিটি ইভেন্টে কারা রেজিস্ট্রেশন করছে, তাদের তথ্য (wp\_postmeta-এ রাখা কষ্টকর ও অদক্ষ)। রেজিস্ট্রেশনের তথ্যের জন্য একটি কাস্টম registrations টেবিল বানানো অনেক বেশি যৌক্তিক, যেখানে registration\_id, event\_id, user\_name, user\_email এর মতো কলাম থাকবে।

#### **৩.৩ কাস্টম টেবিল তৈরি ও ম্যানেজ করা**

কাস্টম টেবিল তৈরির জন্য ওয়ার্ডপ্রেসের স্ট্যান্ডার্ড উপায় হলো dbDelta() ফাংশন ব্যবহার করা। এই ফাংশনটি প্লাগিন অ্যাক্টিভেশনের সময় চালানো হয়।

dbDelta() এর সবচেয়ে বড় সুবিধা হলো এটি শুধু টেবিল তৈরিই করে না, বরং আপনার প্লাগিনের ভবিষ্যৎ আপডেটের সময় টেবিলের স্ট্রাকচার পরিবর্তনও করতে পারে (যেমন: নতুন কলাম যোগ করা)। এটি টেবিলটিকে আপনার দেওয়া SQL স্কিমার সাথে তুলনা করে এবং প্রয়োজনীয় পরিবর্তনগুলো করে ফেলে।

প্রক্রিয়া:

1.  প্লাগিন অ্যাক্টিভেশন হুকে একটি ফাংশন রেজিস্টার করুন।

2.  সেই ফাংশনের ভেতর আপনার টেবিলের SQL CREATE TABLE স্কিমা তৈরি করুন।

3.  ওয়ার্ডপ্রেসের upgrade.php ফাইলটি require\_once করুন, কারণ dbDelta() ফাংশনটি সেখানে থাকে।

4.  dbDelta() ফাংশনটিকে আপনার SQL স্কিমা দিয়ে কল করুন।


পূর্ণাঙ্গ উদাহরণ:

আমাদের "Awesome Events Manager" প্লাগিনের জন্য একটি লগ টেবিল তৈরি করা যাক।

```PHP
<?php
// awesome-events-manager.php (মূল প্লাগিন ফাইল)

// অ্যাক্টিভেশন হুক রেজিস্টার করা
register_activation_hook(__FILE__, 'aem_activate_plugin');

function aem_activate_plugin() {
    // অ্যাক্টিভেশনের সময় আমাদের টেবিল তৈরির ফাংশনটি কল করা হবে
    create_event_log_table();
}

function create_event_log_table() {
    global $wpdb;
    $table_name = $wpdb->prefix . 'aem_event_logs';
    $charset_collate = $wpdb->get_charset_collate();

    // টেবিলের SQL স্কিমা
    $sql = "CREATE TABLE $table_name (
        log_id mediumint(9) NOT NULL AUTO_INCREMENT,
        event_id bigint(20) NOT NULL,
        log_message text NOT NULL,
        created_at datetime DEFAULT '0000-00-00 00:00:00' NOT NULL,
        PRIMARY KEY  (log_id)
    ) $charset_collate;";

    // dbDelta ফাংশনটি upgrade.php ফাইলে থাকে
    require_once(ABSPATH . 'wp-admin/includes/upgrade.php');
    dbDelta($sql);
}
```

এই কোডটি যখন প্রথমবার প্লাগিন অ্যাক্টিভেট হবে, তখন wp\_aem\_event\_logs নামে একটি নতুন টেবিল তৈরি করবে। পরবর্তীতে আপনি যদি প্লাগিনের নতুন ভার্সনে এই টেবিলে কোনো নতুন কলাম যোগ করতে চান, শুধু SQL স্কিমাটি আপডেট করে দিলেই dbDelta() বাকি কাজটুকু করে নেবে।

#### সারসংক্ষেপ

এই অধ্যায়ে আমরা ডেটাবেস ম্যানেজমেন্টের কিছু গুরুত্বপূর্ণ বিষয় শিখেছি যা আপনাকে একজন সাধারণ প্লাগিন ডেভেলপার থেকে পেশাদার স্তরে নিয়ে যেতে সাহায্য করবে। আমরা জেনেছি:

*   $wpdb অবজেক্ট ওয়ার্ডপ্রেস ডেটাবেসের সাথে কাজ করার নিরাপদ মাধ্যম।

*   SQL Injection প্রতিরোধ করতে $wpdb->prepare() ব্যবহার করা অপরিহার্য।

*   স্ট্রাকচারড, হাই-ভলিউম বা রিলেশনাল ডেটার জন্য কাস্টম ডেটাবেস টেবিল একটি সেরা সমাধান।

*   dbDelta() ফাংশন ব্যবহার করে প্লাগিন অ্যাক্টিভেশন ও আপডেটের সময় কাস্টম টেবিল তৈরি এবং রক্ষণাবেক্ষণ করা যায়।


পরবর্তী অধ্যায়ে...

এখন যেহেতু আমরা ডেটাবেসের নিম্ন স্তরে (low-level) কাজ করতে শিখেছি, এবার সময় হয়েছে ওয়ার্ডপ্রেসের শক্তিশালী বিল্ট-ইন API-গুলো নিয়ে কাজ করার। পরবর্তী অধ্যায়ে আমরা দেখব কীভাবে Settings API ব্যবহার করে ইউজার-ফ্রেন্ডলি অপশন পেজ তৈরি করা যায় এবং REST API ব্যবহার করে কীভাবে আপনার প্লাগিনের ডেটাকে বাইরের অ্যাপ্লিকেশনের জন্য উন্মুক্ত করা যায়।
